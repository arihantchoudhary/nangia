# API Documentation for Neeraj's Assistant Dashboard

## Overview

This document outlines the API endpoints needed to power the assistant dashboard. The backend will integrate with 11 Labs for voice conversations and use Gemini (or similar) for data extraction from transcripts.

## Architecture Flow

```
11 Labs Agent → Conversations API → Data Extraction (Gemini) → Dashboard Frontend
```

## Required API Endpoints

### 1. GET /api/callers
Returns all conversations with extracted metadata.

**Response Format:**
```json
{
  "conversationsByDate": {
    "Today": [
      {
        "id": "conv_123",
        "title": "Technical Support - John Doe",
        "subtitle": "Technical Support",
        "time": "2:30 PM",
        "meetingDuration": 30,
        "urgency": "High",
        "fullData": {
          "id": 1,
          "callerName": "John Doe",
          "title": "Software Engineer",
          "issueType": "Technical Support",
          "meetingDuration": 30,
          "urgency": "High",
          "timeRequested": "2024-01-20T14:30:00Z",
          "createdAt": "2024-01-20T14:30:00Z",
          "dateLabel": "Today",
          "displayTime": "2:30 PM",
          "subtitle": "Technical Support",
          "phoneNumber": "+1 (555) 123-4567",
          "email": "john.doe@example.com",
          "transcript": "[Full transcript text]"
        }
      }
    ],
    "Yesterday": [...],
    "Monday": [...]
  },
  "allCallers": [...],
  "total": 10
}
```

### 2. GET /api/stats
Returns aggregated statistics for the dashboard hero section.

**Response Format:**
```json
{
  "callsLastWeek": 47,
  "peopleSpokenTo": 23
}
```

## Data Extraction Requirements

When processing conversations from 11 Labs, extract the following fields from each conversation:

### Required Fields from Transcript

1. **callerName** (string) - Extract from the beginning of conversation
2. **title** (string) - The person's job title/role
3. **issueType** (string) - Categorize as one of:
   - "Technical Support"
   - "Feature Request"
   - "Bug Report"
   - "Infrastructure"
   - "General Inquiry"
   - "Team Management"
   - "Process Improvement"
4. **meetingDuration** (number) - Must be 15, 30, 45, or 60 minutes
5. **urgency** (string) - Extract from 1-5 scale and map to:
   - 5 → "Critical"
   - 4 → "High"
   - 3 → "Medium"
   - 1-2 → "Low"
6. **email** (string) - Extract if mentioned in conversation
7. **phoneNumber** (string) - Extract if mentioned in conversation
8. **agenda** (string) - Main topics to be covered in the meeting

### Generated Fields

These fields should be generated by your backend:

1. **id** (number/string) - Unique identifier
2. **timeRequested** (ISO string) - When the call occurred
3. **createdAt** (ISO string) - When the record was created
4. **dateLabel** (string) - "Today", "Yesterday", or day of week
5. **displayTime** (string) - Formatted time like "2:30 PM"
6. **subtitle** (string) - Secondary categorization for display
7. **transcript** (string) - Full conversation transcript from 11 Labs

## Implementation Guide

### Step 1: Set up 11 Labs Webhook/API Integration

1. Configure 11 Labs to send conversation data to your webhook endpoint
2. Create endpoint: `POST /api/webhook/elevenlabs-conversation`

```javascript
// Webhook handler example
app.post('/api/webhook/elevenlabs-conversation', async (req, res) => {
  const { conversationId, transcript, startTime, endTime, metadata } = req.body;
  
  // Store raw conversation
  await storeRawConversation({
    conversationId,
    transcript,
    startTime,
    endTime,
    metadata
  });
  
  // Trigger async processing
  await processConversationAsync(conversationId);
  
  res.status(200).json({ received: true });
});
```

### Step 2: Extract Data from Transcript

Create a data extraction service using Gemini API:

```javascript
async function extractConversationData(transcript) {
  const prompt = `
    Extract the following information from this conversation transcript:
    
    1. Caller's full name
    2. Caller's job title/role
    3. Issue type (categorize as: Technical Support, Feature Request, Bug Report, Infrastructure, General Inquiry, Team Management, or Process Improvement)
    4. Meeting duration requested (must be 15, 30, 45, or 60 minutes)
    5. Urgency level (1-5 scale)
    6. Email address (if mentioned)
    7. Phone number (if mentioned)
    8. Main agenda items for the meeting
    
    Transcript:
    ${transcript}
    
    Return as JSON with keys: callerName, title, issueType, meetingDuration, urgencyScore, email, phoneNumber, agenda
  `;
  
  const response = await geminiAPI.generateContent(prompt);
  return JSON.parse(response);
}
```

### Step 3: Process and Store Conversation

```javascript
async function processConversationAsync(conversationId) {
  // Get raw conversation
  const rawConversation = await getRawConversation(conversationId);
  
  // Extract data using Gemini
  const extractedData = await extractConversationData(rawConversation.transcript);
  
  // Map urgency score to label
  const urgencyMap = {
    5: "Critical",
    4: "High", 
    3: "Medium",
    2: "Low",
    1: "Low"
  };
  
  // Create processed conversation record
  const processedConversation = {
    id: conversationId,
    callerName: extractedData.callerName,
    title: extractedData.title,
    issueType: extractedData.issueType,
    meetingDuration: extractedData.meetingDuration,
    urgency: urgencyMap[extractedData.urgencyScore],
    timeRequested: rawConversation.startTime,
    createdAt: new Date().toISOString(),
    dateLabel: getDateLabel(new Date(rawConversation.startTime)),
    displayTime: formatTime(rawConversation.startTime),
    subtitle: extractedData.issueType,
    phoneNumber: extractedData.phoneNumber || "Not provided",
    email: extractedData.email || "Not provided",
    transcript: rawConversation.transcript,
    agenda: extractedData.agenda
  };
  
  // Store in database
  await storeProcessedConversation(processedConversation);
}
```

### Step 4: Implement API Endpoints

```javascript
// GET /api/callers
app.get('/api/callers', async (req, res) => {
  const conversations = await getProcessedConversations();
  
  // Group by date
  const conversationsByDate = groupConversationsByDate(conversations);
  
  res.json({
    conversationsByDate,
    allCallers: conversations,
    total: conversations.length
  });
});

// GET /api/stats
app.get('/api/stats', async (req, res) => {
  const oneWeekAgo = new Date();
  oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
  
  const stats = await getConversationStats(oneWeekAgo);
  
  res.json({
    callsLastWeek: stats.totalCalls,
    peopleSpokenTo: stats.uniqueCallers
  });
});
```

### Step 5: Helper Functions

```javascript
function getDateLabel(date) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);
  
  const inputDate = new Date(date);
  inputDate.setHours(0, 0, 0, 0);
  
  if (inputDate.getTime() === today.getTime()) return "Today";
  if (inputDate.getTime() === yesterday.getTime()) return "Yesterday";
  
  const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  return days[inputDate.getDay()];
}

function formatTime(dateString) {
  return new Date(dateString).toLocaleTimeString('en-US', { 
    hour: 'numeric', 
    minute: '2-digit' 
  });
}

function groupConversationsByDate(conversations) {
  return conversations.reduce((acc, conversation) => {
    const dateLabel = conversation.dateLabel;
    if (!acc[dateLabel]) {
      acc[dateLabel] = [];
    }
    acc[dateLabel].push({
      id: conversation.id.toString(),
      title: `${conversation.issueType} - ${conversation.callerName}`,
      subtitle: conversation.subtitle,
      time: conversation.displayTime,
      meetingDuration: conversation.meetingDuration,
      urgency: conversation.urgency,
      fullData: conversation
    });
    return acc;
  }, {});
}
```

## Database Schema

### conversations_raw table
```sql
CREATE TABLE conversations_raw (
  id VARCHAR(255) PRIMARY KEY,
  transcript TEXT NOT NULL,
  start_time TIMESTAMP NOT NULL,
  end_time TIMESTAMP NOT NULL,
  metadata JSON,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### conversations_processed table
```sql
CREATE TABLE conversations_processed (
  id VARCHAR(255) PRIMARY KEY,
  caller_name VARCHAR(255) NOT NULL,
  title VARCHAR(255),
  issue_type VARCHAR(100) NOT NULL,
  meeting_duration INTEGER NOT NULL CHECK (meeting_duration IN (15, 30, 45, 60)),
  urgency VARCHAR(20) NOT NULL,
  time_requested TIMESTAMP NOT NULL,
  phone_number VARCHAR(50),
  email VARCHAR(255),
  transcript TEXT NOT NULL,
  agenda TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (id) REFERENCES conversations_raw(id)
);
```

## Error Handling

1. **Failed Data Extraction**: If Gemini fails to extract data, flag the conversation for manual review
2. **Missing Required Fields**: Use defaults or prompt for manual input
3. **Invalid Meeting Duration**: Default to 30 minutes if not 15, 30, 45, or 60

## Testing the Integration

1. Create test conversations in 11 Labs
2. Verify webhook receives data correctly
3. Check data extraction accuracy
4. Validate API responses match expected format
5. Test edge cases (missing data, long transcripts, multiple speakers)

## Security Considerations

1. Authenticate webhook requests from 11 Labs
2. Validate and sanitize extracted data
3. Implement rate limiting on API endpoints
4. Use proper authentication for dashboard API access
5. Encrypt sensitive data in database